import{_ as i,c as s,o as n,aS as a}from"./chunks/framework.SeHPajDF.js";const u=JSON.parse('{"title":"阮一峰 TypeScript 学习笔记","description":"","frontmatter":{},"headers":[],"relativePath":"typescript/index.md","filePath":"typescript/index.md","lastUpdated":1715521816000}'),e={name:"typescript/index.md"},t=a(`<h1 id="阮一峰-typescript-学习笔记" tabindex="-1">阮一峰 TypeScript 学习笔记 <a class="header-anchor" href="#阮一峰-typescript-学习笔记" aria-label="Permalink to &quot;阮一峰 TypeScript 学习笔记&quot;">​</a></h1><blockquote><p><a href="https://wangdoc.com/typescript/" target="_blank" rel="noreferrer">教程原文</a></p><p>祝阮一峰老师长命百岁</p></blockquote><h2 id="_1-any-类型、unknown-类型、never-类型" tabindex="-1">1. any 类型、unknown 类型、never 类型 <a class="header-anchor" href="#_1-any-类型、unknown-类型、never-类型" aria-label="Permalink to &quot;1. any 类型、unknown 类型、never 类型&quot;">​</a></h2><h3 id="any-类型" tabindex="-1">any 类型 <a class="header-anchor" href="#any-类型" aria-label="Permalink to &quot;any 类型&quot;">​</a></h3><ul><li>any 类型相当于关闭了 TS 的类型检查</li><li>应该尽量避免使用 any 类型，否则就失去了使用 TypeScript 的意义</li><li>实际开发中，any 类型主要适用以下两个场合 <ol><li>需要用 any 类型的时候</li><li>兼容老 JS 项目</li></ol></li><li><strong>类型污染</strong>，当 any 类型变量给别的变量赋值时，该被赋值的变量也会被污染为 any 类型，失去类型检查。不仅如此，这个错误还非常不容易被发现，只有当运行时才会显现</li></ul><h3 id="unknown-类型" tabindex="-1">unknown 类型 <a class="header-anchor" href="#unknown-类型" aria-label="Permalink to &quot;unknown 类型&quot;">​</a></h3><ul><li>为了解决 any 的类型污染，TS3.0 引入了 unknown 类型</li><li>跟 any 差不多，但有一些特殊限制： <ol><li>unknown 类型的变量，不能直接赋值给其他类型的变量（除了 any 类型和 unknown 类型）</li><li>不能直接调用 unknown 类型变量的方法和属性</li><li>unknown 类型变量能够进行的运算是有限的，只能进行比较运算（运算符==、===、!=、!==、||、&amp;&amp;、?）、取反运算（运算符!）、typeof 运算符和 instanceof 运算符这几种，其他运算都会报错</li></ol></li><li>如何使用 unknown 类型？<strong>类型缩小</strong></li></ul><div class="language-ts vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> unknown</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">typeof</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;number&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> r </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 正确</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>unknown 可以看作是更安全的 any。一般来说，凡是需要设为 any 类型的地方，通常都应该优先考虑设为 unknown 类型</li></ul>`,9),l=[t];function p(r,h,k,o,d,c){return n(),s("div",null,l)}const E=i(e,[["render",p]]);export{u as __pageData,E as default};
