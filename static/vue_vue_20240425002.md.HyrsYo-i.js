import{_ as e,c as t,o as r,a6 as a}from"./chunks/framework.D-gvsjl0.js";const l=JSON.parse('{"title":"ref 无法获取的解决方案","description":"","frontmatter":{},"headers":[],"relativePath":"vue/vue/20240425002.md","filePath":"vue/vue/20240425002.md","lastUpdated":1715521816000}'),o={name:"vue/vue/20240425002.md"},s=a('<h1 id="ref-无法获取的解决方案" tabindex="-1">ref 无法获取的解决方案 <a class="header-anchor" href="#ref-无法获取的解决方案" aria-label="Permalink to &quot;ref 无法获取的解决方案&quot;">​</a></h1><p><a href="https://blog.csdn.net/changzhen11/article/details/84067816?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160549466819724838534914%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=160549466819724838534914&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-84067816.pc_first_rank_v2_rank_v28&amp;utm_term=vue+ref+undefined&amp;spm=1018.2118.3001.4449" target="_blank" rel="noreferrer">原文看这里</a></p><p>用 ref 注册子组件，父组件可以通过 this.$refs.xx.fn 调用子组件里的函数，但是有时会出现 fn 为定义的情况，这是为什么呢？</p><p>vue 官网中 ref 下有一段话</p><blockquote><p>&quot;关于 ref 注册时间的重要说明：因为 ref 本身是作为渲染结果被创建的，在初始渲染的时候你不能访问它们 - 它们还不存在！$refs 也不是响应式的，因此你不应该试图用它在模板中做数据绑定。&quot;</p></blockquote><p>也就是说 ref 只有等页面加载完成好之后你才能调用 this.$refs ，如果你使用v-if 、v-for渲染页面的话，那么在刚开始页面没没渲染之前你是拿不到this.$refs 的，所以要等到页面渲染之后拿才可以</p><hr><h3 id="解决办法" tabindex="-1">解决办法： <a class="header-anchor" href="#解决办法" aria-label="Permalink to &quot;解决办法：&quot;">​</a></h3><p>1、如果你在 <code>mounted</code> 里获取 <code>this.$refs</code>，因为 dom 还未完全加载，所以你是拿不到的， update 阶段则是完成了数据更新到 DOM 的阶段(对加载回来的数据进行处理)，此时，就可以使用 this.$refs 了</p><p>2、如果写在 <code>method</code> 中，那么可以使用 <code>this.$nextTick(() =&gt; {})</code> 等页面渲染好再调用，这样就可以了</p><p>3、或者加个定时器延时加载 <code>this.$refs</code>（这个方法还没有试）</p>',11),d=[s];function c(i,_,n,p,f,u){return r(),t("div",null,d)}const m=e(o,[["render",c]]);export{l as __pageData,m as default};
